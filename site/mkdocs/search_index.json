{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n#\n\n\nGraphCMS is a GraphQL based headless CMS. It allows you to build rich content APIs within minutes while taking full advantage of the powerful GraphQL language. Your choice: content stored in GraphCMS can be delivered with a \nsimple\n and/or \nrelay compliant\n GraphQL endpoint.\n\n\nGraphCMS allows you to build websites and applications that are not restricted to any specific templating or frontend framework. We store your content and your frontend developers choose how they like to present it. Simply consider GraphCMS as a flexible content management system for your websites, web apps, mobile apps, smartwatch and TV apps and for what is yet to come.\n\n\nIn this docs we will show you how to setup a project, define your content model, manage your content and connect your applications.\n\n\nNew to GraphQL?\n#\n\n\nGraphQL\n is a data query language and runtime designed and used at Facebook to request and deliver data to any kind of websites and apps since 2012.\n\n\nKey Benefits\n#\n\n\nWhy did we choose to build GraphCMS around GraphQL?\n\n\nOne Endpoint to Rule Them All\n#\n\n\nWith GraphQL as a query language, it is up to your client application to specify the shape of the data it requires from the server. A GraphQL query returns exactly what a client asks for and no more. There is just one endpoint on the server that is capable of serving all the data that is requested.\n\n\nDeclarative and Strongly-Typed\n#\n\n\nThe GraphQL type system helps to ensure that your queries are valid at the time of development. This saves you from frustration of invalid queries and boosts your productivity.\n\n\nMinimum Payload\n#\n\n\nSince your application receives only the data it requested, the payload is limited to the minimum. This is especially important in mobile or low bandwidth scenarios. Also communication overhead is reduced: querying a complex content graph, GraphQL will be able to deliver all data in just one round trip.\n\n\nGenerated API Documentation\n#\n\n\nWriting and maintaining API documentation can be cumbersome. With GraphQL, you don't have to worry about documentation at all. Through introspection all of your API documentation will be generated automatically.\n\n\n\n\nIf you want to learn more about GraphQL, we recommend you to visit the \nGraphQL.org\n website as a good starting point.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#introduction", 
            "text": "GraphCMS is a GraphQL based headless CMS. It allows you to build rich content APIs within minutes while taking full advantage of the powerful GraphQL language. Your choice: content stored in GraphCMS can be delivered with a  simple  and/or  relay compliant  GraphQL endpoint.  GraphCMS allows you to build websites and applications that are not restricted to any specific templating or frontend framework. We store your content and your frontend developers choose how they like to present it. Simply consider GraphCMS as a flexible content management system for your websites, web apps, mobile apps, smartwatch and TV apps and for what is yet to come.  In this docs we will show you how to setup a project, define your content model, manage your content and connect your applications.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#new-to-graphql", 
            "text": "GraphQL  is a data query language and runtime designed and used at Facebook to request and deliver data to any kind of websites and apps since 2012.", 
            "title": "New to GraphQL?"
        }, 
        {
            "location": "/#key-benefits", 
            "text": "Why did we choose to build GraphCMS around GraphQL?", 
            "title": "Key Benefits"
        }, 
        {
            "location": "/#one-endpoint-to-rule-them-all", 
            "text": "With GraphQL as a query language, it is up to your client application to specify the shape of the data it requires from the server. A GraphQL query returns exactly what a client asks for and no more. There is just one endpoint on the server that is capable of serving all the data that is requested.", 
            "title": "One Endpoint to Rule Them All"
        }, 
        {
            "location": "/#declarative-and-strongly-typed", 
            "text": "The GraphQL type system helps to ensure that your queries are valid at the time of development. This saves you from frustration of invalid queries and boosts your productivity.", 
            "title": "Declarative and Strongly-Typed"
        }, 
        {
            "location": "/#minimum-payload", 
            "text": "Since your application receives only the data it requested, the payload is limited to the minimum. This is especially important in mobile or low bandwidth scenarios. Also communication overhead is reduced: querying a complex content graph, GraphQL will be able to deliver all data in just one round trip.", 
            "title": "Minimum Payload"
        }, 
        {
            "location": "/#generated-api-documentation", 
            "text": "Writing and maintaining API documentation can be cumbersome. With GraphQL, you don't have to worry about documentation at all. Through introspection all of your API documentation will be generated automatically.   If you want to learn more about GraphQL, we recommend you to visit the  GraphQL.org  website as a good starting point.", 
            "title": "Generated API Documentation"
        }, 
        {
            "location": "/Concepts/", 
            "text": "Concepts\n#\n\n\nA quick overview on the concepts of GraphCMS.\n\n\nProjects\n#\n\n\nYour content lives within a project. In a project you can:\n\n\n\n\nDefine the shape of your content by adding \ncontent models\n\n\nAdd \nfields\n to your models\n\n\nManage and browse your project\u00b4s content\n\n\nUpload and assign media files\n\n\nInvite others to your team\n\n\nTrack the activities of your team\n\n\nCreate \npermanent auth tokens\n for your applications and content consumers\n\n\nUse the integrated GraphiQL playground to run queries and mutations against your project\u00b4s endpoint\n\n\n\n\nContent Models\n#\n\n\nContent models describe the shape of your content. They consist of several fields while each field can store various types of data (e.g: text, numbers or images). A field can also be a reference to another model, which allows you to build a complex content graph. The fields you associate with a model will also define how its content editing user interface will look like.\n\n\nFields\n#\n\n\nFields are the building blocks of your content models. Each field type can store a specific type of data.\nGraphCMS offers the following field types:\n\n\n\n\nText:\n names, titles, list of names, comments, formatted text, markdown...\n\n\nNumber:\n ID, product number, price, quantity...\n\n\nBoolean:\n true or false, yes or no...\n\n\nDate:\n post date, opening hours, date of birth...\n\n\nEnum:\n selection on a predefined set of values\n\n\nJSON:\n data in JSON format\n\n\nColor:\n rgba or hex color string\n\n\nLocation:\n geographic coordinates: latitude and longitude\n\n\nMedia:\n any asset, e.g. image, video...\n\n\nRelation:\n for referencing other content models. E.g. the author of a blog post\n\n\n\n\n\n\nGraphQL Endpoints\n#\n\n\nAny GraphCMS project comes with two GraphQL endpoints:\n\n\n\n\nThe \nsimple endpoint\n serves your content with a simple GraphQL schema for use with GraphQL clients like \nApollo\n, \nApollo iOS\n or \nLokka\n\n\nThe \nrelay endpoint\n serves your content with a relay conform GraphQL schema for \ndata driven react applications\n  \n\n\n\n\nPermanent Auth Tokens\n#\n\n\nTo connect your client applications to your GraphCMS project, you will need to create a \npermanent auth token\n in your project\u00b4s settings. This will allow your client to:\n\n\n\n\nCREATE\n new content entries\n\n\nREAD\n existing content entries\n\n\nUPDATE\n existing content entries\n\n\nDELETE\n existing content entries\n\n\n\n\n\n\nBe careful! Anyone that knows one of your tokens will be able to execute all of these operations and manipulate your content. So it is never a good idea to store a token on the client side, i.e. a JavaScript client application.\n\n\nWe will soon release a feature that will allow you to create \nread-only tokens\n, so even if someone gains access to such a token, your data will be safe from manipulation.", 
            "title": "Concepts"
        }, 
        {
            "location": "/Concepts/#concepts", 
            "text": "A quick overview on the concepts of GraphCMS.", 
            "title": "Concepts"
        }, 
        {
            "location": "/Concepts/#projects", 
            "text": "Your content lives within a project. In a project you can:   Define the shape of your content by adding  content models  Add  fields  to your models  Manage and browse your project\u00b4s content  Upload and assign media files  Invite others to your team  Track the activities of your team  Create  permanent auth tokens  for your applications and content consumers  Use the integrated GraphiQL playground to run queries and mutations against your project\u00b4s endpoint", 
            "title": "Projects"
        }, 
        {
            "location": "/Concepts/#content-models", 
            "text": "Content models describe the shape of your content. They consist of several fields while each field can store various types of data (e.g: text, numbers or images). A field can also be a reference to another model, which allows you to build a complex content graph. The fields you associate with a model will also define how its content editing user interface will look like.", 
            "title": "Content Models"
        }, 
        {
            "location": "/Concepts/#fields", 
            "text": "Fields are the building blocks of your content models. Each field type can store a specific type of data.\nGraphCMS offers the following field types:   Text:  names, titles, list of names, comments, formatted text, markdown...  Number:  ID, product number, price, quantity...  Boolean:  true or false, yes or no...  Date:  post date, opening hours, date of birth...  Enum:  selection on a predefined set of values  JSON:  data in JSON format  Color:  rgba or hex color string  Location:  geographic coordinates: latitude and longitude  Media:  any asset, e.g. image, video...  Relation:  for referencing other content models. E.g. the author of a blog post", 
            "title": "Fields"
        }, 
        {
            "location": "/Concepts/#graphql-endpoints", 
            "text": "Any GraphCMS project comes with two GraphQL endpoints:   The  simple endpoint  serves your content with a simple GraphQL schema for use with GraphQL clients like  Apollo ,  Apollo iOS  or  Lokka  The  relay endpoint  serves your content with a relay conform GraphQL schema for  data driven react applications", 
            "title": "GraphQL Endpoints"
        }, 
        {
            "location": "/Concepts/#permanent-auth-tokens", 
            "text": "To connect your client applications to your GraphCMS project, you will need to create a  permanent auth token  in your project\u00b4s settings. This will allow your client to:   CREATE  new content entries  READ  existing content entries  UPDATE  existing content entries  DELETE  existing content entries    Be careful! Anyone that knows one of your tokens will be able to execute all of these operations and manipulate your content. So it is never a good idea to store a token on the client side, i.e. a JavaScript client application.  We will soon release a feature that will allow you to create  read-only tokens , so even if someone gains access to such a token, your data will be safe from manipulation.", 
            "title": "Permanent Auth Tokens"
        }, 
        {
            "location": "/Getting_Started/", 
            "text": "Getting Started\n#\n\n\nBuilding a content API with GraphCMS is easy! In this getting started guide we will present how to quickly build a content API for a music blog.\n\n\nCreating a Project\n#\n\n\nWe start off by creating a new project called \nVinylbase\n.\n\n\n\n\n\n\nProject names can contain only alphanumeric characters and whitespaces.\n\n\n\n\nCreating Content Models\n#\n\n\nAfter creating the project, switch to the \nCONTENT\n view and use the \nADD MODEL\n button to add the following models:\n\n\n\n\nArist\n\n\nRecord\n\n\nReview\n\n\nRecord Store\n\n\n\n\n\n\n\n\nAPI IDs for models must start with a capital letter and can contain only alphanumeric characters. No whitespaces allowed.\n\n\n\n\nAdding Fields to your Content Models\n#\n\n\nBefore we can populate our content models with content, we need to add fields to them. This can be done by clicking on the small gear icon next to the content model in the sidebar or by clicking on a content model and then clicking the \nEDIT FIELDS\n button.\n\n\nDoing so will open up the \nField Wizard\n. Here we can specify the types, appearance, API identifiers and additional rules for the fields we add to our content model.\n\n\n\n\nFields for model Artist\n#\n\n\nFor content model \nArtist\n, we will add three fields:\n\n\n\n\nName\n\n\nPictures\n\n\nRecords\n\n\n\n\nFor \nName\n we use a \nSingle Line Text Field\n that we set as \nrequired\n. The \nDisplay Name\n allows you define how the field will be displayed in the web interface, while the \nAPI ID\n defines how the field will be named in your content API.\n\n\n\n\n\n\nIn the web interface, API IDs are prefixed with a \n#\n (e.g.: \n#name\n).\n\n\nAPI IDs for fields must start with a lowercase letter and can contain only alphanumeric characters.\n\n\n\n\nFor field \nPictures\n we will add a media field and check \nAllow multiple values\n, this will allow us to store an arbitrary number of media files.\n\n\nWe will now add a relation to this model. Relations allow you to connect two content models. In this case, we create an \nArtistRecord Relation\n, since we want to connect artists to existing records. The \nRelation Name\n defines how the relation will be named in your content API.\n\n\n\n\nWe will set up the relation so that an \nArtist\n can have \nmany\n \n#records\n, while on the reverse side, a \nRecord\n can also have \nmany\n \n#artists\n.\n\n\n\n\nRelation names must start with a capital letter and can contain only alphanumeric characters\n\n\n\n\nYou can now see all fields that are attached to model.\n\n\n\n\n\n\nNotice that there are three additional fields: \nID\n, \nCreatedAt\n and \nUpdatedAt\n. These are system fields and cannot be removed or modified.\n\n\n\n\nFields for model Record\n#\n\n\nThis model will store content for music records. The fields will be:\n\n\n\n\nTitle \n#title\n \nSingle Line Text\n \nrequired\n\n\nTracklist \n#tracklist\n \nSingle Line Text\n \nAllow multiple values\n\n\nCover \n#cover\n \nMedia\n\n\n\n\nNoticed the relation field with API ID \n#artists\n on this model? This field entry is here because it is the \nreverse side\n of the \nArtistRecord Relation\n we created before. Since we are building a GraphQL content API, we need to be able to traverse in both directions.\n\n\nFields for model Review\n#\n\n\nFor content model \nReview\n, we add the following fields:\n\n\n\n\nTitle \n#title\n \nSingle Line Text\n \nrequired\n\n\nRecord \n#record\n \nOne-to-Many Relation on model Record\n. This will again add another reverse relation field on model \nRecord\n, which we named \n#reviews\n\n\nReview \n#review\n \nMarkdown Text\n\n\n\n\nFields for model Record Store\n#\n\n\nThe last content model that we are going to configure will store information about record stores and the records they have in stock.\n\n\nField configuration:\n\n\n\n\nName \n#name\n \nSingle Line Text\n \nrequired\n\n\nLocation \n#location\n \nMarkdown Text\n\n\nArticles \n#articles\n \nMany-to-Many Relation on model Record\n. This will again add another reverse relation field on model \nRecord\n, which we named \n#stores\n.\n\n\n\n\nGreat! We can now start to create our content.\n\n\nCreating Content\n#\n\n\nWe will start by adding a \nContent Entry\n of type \nRecord\n. We can do so by clicking on the small plus icon next to the model in the sidebar or by clicking the model and then clicking on the \nNEW ENTRY\n button.\n\n\nCreating a \nrecord\n#\n\n\nWe are now able to use the input form elements to populate our content. The presentation of the input fields depend on the field configuration we did before.\nFor example, field \n#cover\n is of type \nMedia\n, so it will allow you to upload media to your project and attach it to your record.\n\n\n\n\n\n\nBefore uploading, you can crop pictures within the upload widget.\n\n\nAll uploaded files can be found in the \nMEDIA\n section.\n\n\n\n\nWe will leave the relation fields blank for now, since we don\u00b4t have any content entries that could be assigned.\n\n\nWe can save the entry now by clicking the \nSAVE\n button. This will take us to the overview of our \nRecord\n content entries.\n\n\nCreating an \nartist\n#\n\n\nNow let us create a \nContent Entry\n of type \nArtist\n. We do this in the same way as we did with the \nRecord Entry\n. Except this time we will be able to assign an entry to the relation field \n#records\n. Let\u00b4s assign the record we created previously!\n\n\n\n\nCreating a \nreview\n#\n\n\nLet us now add a review to \nHannah Popanna\u00b4s\n new record. Here we can use a markdown editor to write a sophisticated critique.\n\n\n\n\nCreating a \nrecord store\n#\n\n\nAlmost done! In the last step, we create an entry for a \nRecord Store\n. To add a location to it, we can use the maps widget.\n\n\nCool. Now that we are done with our content creation, let\u00b4s start to explore our GraphQL content API in the \nAPI EXPLORER\n\n\n\n\nExploring the Content API\n#\n\n\nIn the \nAPI EXPLORER\n, we can switch between the \nsimple\n GraphQL endpoint and the \nrelay\n endpoint. Both endpoints are serving our project\u00b4s content, but in different ways. For now, we will choose the \nsimple\n endpoint.\n\n\nWe can start typing in a GraphQL query with the integrated GraphiQL editor. Let us send the following query to the server:\n\n\n{\n  allRecordStores {\n    name\n    location\n    articles {\n      title\n      cover {\n        fileName\n        url\n      }\n      tracklist\n      artists {\n        name\n        pictures {\n          url\n          size\n        }\n      }\n      reviews {\n        title\n        review\n      }\n    }\n  }\n}\n\n\n\n\n\nWill respond with:\n\n\n{\n\n  \ndata\n:\n \n{\n\n    \nallRecordStores\n:\n \n[\n\n      \n{\n\n        \nname\n:\n \nChampionship Vinyl\n,\n\n        \nlocation\n:\n \n{\n\n          \nlat\n:\n \n50.81655790000001\n,\n\n          \nlng\n:\n \n8.76931209999998\n\n        \n},\n\n        \narticles\n:\n \n[\n\n          \n{\n\n            \ntracklist\n:\n \n[\n\n              \nBar blues\n,\n\n              \nA Walk\n,\n\n              \nShine On You Crazy Supernova\n\n            \n],\n\n            \ncover\n:\n \n{\n\n              \nfileName\n:\n \npexels-photo-300849.jpeg\n,\n\n              \nurl\n:\n \nhttps://media.graphcms.com/2D1bXQZLTiGY6Uz8LUqB\n\n            \n},\n\n            \nartists\n:\n \n[\n\n              \n{\n\n                \nname\n:\n \nHannah Popanna\n,\n\n                \npictures\n:\n \n[\n\n                  \n{\n\n                    \nurl\n:\n \nhttps://media.graphcms.com/kgxzNRIIQUanwoBugK5O\n,\n\n                    \nsize\n:\n \n3258909\n\n                  \n}\n\n                \n]\n\n              \n}\n\n            \n],\n\n            \nreviews\n:\n \n[\n\n              \n{\n\n                \ntitle\n:\n \nHannah Popanna\u00b4s new record is da bomb!\n,\n\n                \nreview\n:\n \n# Great stuff!\\n\\nHannah Popanna\u00b4s new record is amazing! Also, I like her hat!\n\n              \n}\n\n            \n],\n\n            \ntitle\n:\n \nTunes from the Void\n\n          \n}\n\n        \n]\n\n      \n}\n\n    \n]\n\n  \n}\n\n\n}\n\n\n\n\n\n\nCool! We can now start building our frontend application. Switch over to the \nSETTINGS\n menu to see your endpoint \nURLs\n and create \nPermanent Auth Tokens\n for your applications.\n\n\n\n\nA full code example will be available soon.\n\n\n\n\nGraphCMS is still in early preview. If you run into an issue, please have a look at the known issues in our \nissue tracker\n. Please don\u00b4t hesitate to open a bug ticket if you experienced an issue that is not covered by those in the tracker.\n\n\n\n\n\n\nIn case you want to know more about the features we are currently working on, please check our public \nroadmap\n.  If you are missing a feature or if you have an idea for additional functionality, please help us to improve by submitting a feature request to this repository.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Getting_Started/#getting-started", 
            "text": "Building a content API with GraphCMS is easy! In this getting started guide we will present how to quickly build a content API for a music blog.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Getting_Started/#creating-a-project", 
            "text": "We start off by creating a new project called  Vinylbase .    Project names can contain only alphanumeric characters and whitespaces.", 
            "title": "Creating a Project"
        }, 
        {
            "location": "/Getting_Started/#creating-content-models", 
            "text": "After creating the project, switch to the  CONTENT  view and use the  ADD MODEL  button to add the following models:   Arist  Record  Review  Record Store     API IDs for models must start with a capital letter and can contain only alphanumeric characters. No whitespaces allowed.", 
            "title": "Creating Content Models"
        }, 
        {
            "location": "/Getting_Started/#adding-fields-to-your-content-models", 
            "text": "Before we can populate our content models with content, we need to add fields to them. This can be done by clicking on the small gear icon next to the content model in the sidebar or by clicking on a content model and then clicking the  EDIT FIELDS  button.  Doing so will open up the  Field Wizard . Here we can specify the types, appearance, API identifiers and additional rules for the fields we add to our content model.", 
            "title": "Adding Fields to your Content Models"
        }, 
        {
            "location": "/Getting_Started/#fields-for-model-artist", 
            "text": "For content model  Artist , we will add three fields:   Name  Pictures  Records   For  Name  we use a  Single Line Text Field  that we set as  required . The  Display Name  allows you define how the field will be displayed in the web interface, while the  API ID  defines how the field will be named in your content API.    In the web interface, API IDs are prefixed with a  #  (e.g.:  #name ).  API IDs for fields must start with a lowercase letter and can contain only alphanumeric characters.   For field  Pictures  we will add a media field and check  Allow multiple values , this will allow us to store an arbitrary number of media files.  We will now add a relation to this model. Relations allow you to connect two content models. In this case, we create an  ArtistRecord Relation , since we want to connect artists to existing records. The  Relation Name  defines how the relation will be named in your content API.   We will set up the relation so that an  Artist  can have  many   #records , while on the reverse side, a  Record  can also have  many   #artists .   Relation names must start with a capital letter and can contain only alphanumeric characters   You can now see all fields that are attached to model.    Notice that there are three additional fields:  ID ,  CreatedAt  and  UpdatedAt . These are system fields and cannot be removed or modified.", 
            "title": "Fields for model Artist"
        }, 
        {
            "location": "/Getting_Started/#fields-for-model-record", 
            "text": "This model will store content for music records. The fields will be:   Title  #title   Single Line Text   required  Tracklist  #tracklist   Single Line Text   Allow multiple values  Cover  #cover   Media   Noticed the relation field with API ID  #artists  on this model? This field entry is here because it is the  reverse side  of the  ArtistRecord Relation  we created before. Since we are building a GraphQL content API, we need to be able to traverse in both directions.", 
            "title": "Fields for model Record"
        }, 
        {
            "location": "/Getting_Started/#fields-for-model-review", 
            "text": "For content model  Review , we add the following fields:   Title  #title   Single Line Text   required  Record  #record   One-to-Many Relation on model Record . This will again add another reverse relation field on model  Record , which we named  #reviews  Review  #review   Markdown Text", 
            "title": "Fields for model Review"
        }, 
        {
            "location": "/Getting_Started/#fields-for-model-record-store", 
            "text": "The last content model that we are going to configure will store information about record stores and the records they have in stock.  Field configuration:   Name  #name   Single Line Text   required  Location  #location   Markdown Text  Articles  #articles   Many-to-Many Relation on model Record . This will again add another reverse relation field on model  Record , which we named  #stores .   Great! We can now start to create our content.", 
            "title": "Fields for model Record Store"
        }, 
        {
            "location": "/Getting_Started/#creating-content", 
            "text": "We will start by adding a  Content Entry  of type  Record . We can do so by clicking on the small plus icon next to the model in the sidebar or by clicking the model and then clicking on the  NEW ENTRY  button.", 
            "title": "Creating Content"
        }, 
        {
            "location": "/Getting_Started/#creating-a-record", 
            "text": "We are now able to use the input form elements to populate our content. The presentation of the input fields depend on the field configuration we did before.\nFor example, field  #cover  is of type  Media , so it will allow you to upload media to your project and attach it to your record.    Before uploading, you can crop pictures within the upload widget.  All uploaded files can be found in the  MEDIA  section.   We will leave the relation fields blank for now, since we don\u00b4t have any content entries that could be assigned.  We can save the entry now by clicking the  SAVE  button. This will take us to the overview of our  Record  content entries.", 
            "title": "Creating a record"
        }, 
        {
            "location": "/Getting_Started/#creating-an-artist", 
            "text": "Now let us create a  Content Entry  of type  Artist . We do this in the same way as we did with the  Record Entry . Except this time we will be able to assign an entry to the relation field  #records . Let\u00b4s assign the record we created previously!", 
            "title": "Creating an artist"
        }, 
        {
            "location": "/Getting_Started/#creating-a-review", 
            "text": "Let us now add a review to  Hannah Popanna\u00b4s  new record. Here we can use a markdown editor to write a sophisticated critique.", 
            "title": "Creating a review"
        }, 
        {
            "location": "/Getting_Started/#creating-a-record-store", 
            "text": "Almost done! In the last step, we create an entry for a  Record Store . To add a location to it, we can use the maps widget.  Cool. Now that we are done with our content creation, let\u00b4s start to explore our GraphQL content API in the  API EXPLORER", 
            "title": "Creating a record store"
        }, 
        {
            "location": "/Getting_Started/#exploring-the-content-api", 
            "text": "In the  API EXPLORER , we can switch between the  simple  GraphQL endpoint and the  relay  endpoint. Both endpoints are serving our project\u00b4s content, but in different ways. For now, we will choose the  simple  endpoint.  We can start typing in a GraphQL query with the integrated GraphiQL editor. Let us send the following query to the server:  {\n  allRecordStores {\n    name\n    location\n    articles {\n      title\n      cover {\n        fileName\n        url\n      }\n      tracklist\n      artists {\n        name\n        pictures {\n          url\n          size\n        }\n      }\n      reviews {\n        title\n        review\n      }\n    }\n  }\n}  Will respond with:  { \n   data :   { \n     allRecordStores :   [ \n       { \n         name :   Championship Vinyl , \n         location :   { \n           lat :   50.81655790000001 , \n           lng :   8.76931209999998 \n         }, \n         articles :   [ \n           { \n             tracklist :   [ \n               Bar blues , \n               A Walk , \n               Shine On You Crazy Supernova \n             ], \n             cover :   { \n               fileName :   pexels-photo-300849.jpeg , \n               url :   https://media.graphcms.com/2D1bXQZLTiGY6Uz8LUqB \n             }, \n             artists :   [ \n               { \n                 name :   Hannah Popanna , \n                 pictures :   [ \n                   { \n                     url :   https://media.graphcms.com/kgxzNRIIQUanwoBugK5O , \n                     size :   3258909 \n                   } \n                 ] \n               } \n             ], \n             reviews :   [ \n               { \n                 title :   Hannah Popanna\u00b4s new record is da bomb! , \n                 review :   # Great stuff!\\n\\nHannah Popanna\u00b4s new record is amazing! Also, I like her hat! \n               } \n             ], \n             title :   Tunes from the Void \n           } \n         ] \n       } \n     ] \n   }  }   Cool! We can now start building our frontend application. Switch over to the  SETTINGS  menu to see your endpoint  URLs  and create  Permanent Auth Tokens  for your applications.   A full code example will be available soon.   GraphCMS is still in early preview. If you run into an issue, please have a look at the known issues in our  issue tracker . Please don\u00b4t hesitate to open a bug ticket if you experienced an issue that is not covered by those in the tracker.    In case you want to know more about the features we are currently working on, please check our public  roadmap .  If you are missing a feature or if you have an idea for additional functionality, please help us to improve by submitting a feature request to this repository.", 
            "title": "Exploring the Content API"
        }, 
        {
            "location": "/Media/", 
            "text": "Media\n#\n\n\nWorking with media is an essential part of content management. GraphCMS allows you to upload and assign media files to any content model in your project. The uploaded files will be assigned to the project\u00b4s internal \nMedia\n model. \nMedia fields\n will then connect the dots between a content model and assigned files.\n\n\nMedia files that are stored in GraphCMS are served via a global content delivery network. This assures quick response times and fast loading of your media.\n\n\n\n\nQuerying a Media Field\n#\n\n\nUploaded media files can be queried from your content API. Let\u00b4s assume we have a content model \nPost\n, with a field configuration of:\n\n\n\n\nTitle \n#title\n \nSingle Line Text\n\n\nImages \n#images\n \nMedia\n \nAllow Multiple Values\n\n\n\n\nThis will allow us to store an arbitrary number of images for a \nPost\n.\n\n\nWe can fetch \nallPosts\n with the following query:\n\n\n{\n  allPosts {\n    title\n    images {\n      fileName\n      handle\n      url\n      mimeType\n      size\n    }\n  }\n}\n\n\n\n\n\nWhich will give us a result like this:\n\n\n{\n  \ndata\n: {\n    \nallPosts\n: [\n      {\n        \ntitle\n: \nSome nice post\n,\n        \nimages\n: [\n          {\n            \nfileName\n: \npexels-photo-295821.jpeg\n,\n            \nhandle\n: \n7AmzJToStuJrNqkpPSWO\n\n            \nurl\n: \nhttps://media.graphcms.com/7AmzJToStuJrNqkpPSWO\n,\n            \nmimeType\n: \nimage/jpeg\n,\n            \nsize\n: 100075,\n          }\n        ]\n      }\n    ]\n  }\n}\n\n\n\n\n\nField \n#images\n will return an array of media objects, which contain the fields:\n\n\n\n\nfileName\n the original file name of the uploaded file\n\n\nhandle\n the identifier of the uploaded file\n\n\nurl\n the full URL to the uploaded file\n\n\nmimeType\n the media type of the uploaded file\n\n\nsize\n the total size in bytes\n\n\n\n\n\n\nIf you know the desired display size of your images, it is highly recommended to use our integrated image transformation engine to scale your images to the desired size. This will increase the loading time of your content and result in a better user experience for your visitors.\n\n\n\n\nGraphCMS Image Transformations\n#\n\n\nAn essential feature of GraphCMS is the image processing engine. It enables you on the fly image transformations, such as resizing or cropping just by adding parameters to your media\u00b4s URL.\n\n\nTransformation URL Structure with GraphCMS Handle\n#\n\n\nhttps://media.graphcms.com/[(1) Transformation Tasks]/[(2) File Handle]\n\n\n\n\n\n1) One or multiple transformation tasks and their parameters\n\n\n2) The source image to run the transformation tasks on.\n\n\nAvailable Transformations\n#\n\n\nAn overview of supported image transformations.\n\n\n\n\nThe maximum accepted image size is 100.000.000 pixels. An image with this many pixels could have width and height combinations like 10.000 x 10.000 or 5.000 x 20.000, etc. The maximum file size of an image can not be larger than 256mb.\n\n\n\n\nResize Fit and Align\n#\n\n\nThe resizing feature comprises two main functions, manipulating the width and height of an image and changing the fit and alignment of the image.\n\n\nResize\n \nTask\n \nURL\n \nFormat\n:\n\n\nhttps\n:\n//media.graphcms.com/resize=[options]/[File Handle]\n\n\n\n\n\n\n\n\nBasic resize example with a GraphCMS file handle\n\n\nhttps://media.graphcms.com/resize=width:300/bYbYJmGyQfynUBaBkRnP\n\n\n\n\n\n\n\n\n\n\n\nresize=width:100\n\n\n\n\nCan be abbreviated as \nw:100\n\n\nThe width in pixels to resize the image to. The value must be an integer from 1 to 10000.\n\n\n\n\n\n\n\n\n\n\n\nresize=height:100\n\n\n\n\nCan be abbreviated as \nh:100\n\n\nThe height in pixels to resize the image to. The value must be an integer from 1 to 10000.\n\n\n\n\n\n\n\n\n\n\n\nresize=fit:clip, crop, scale, or max\n\n\n\n\nCan be abbreviated as \nf:clip\n\n\nThe default value for the fit parameter is \nfit:clip\n.\n\n\n\n\nfit:clip\n\n\n\n\nResizes the image to fit within the specified parameters without distorting, cropping, or changing the aspect ratio.\n\n\n\n\nfit:crop\n\n\n\n\nResizes the image to fit the specified parameters exactly by removing any parts of the image that don't fit within the boundaries.\n\n\n\n\nfit:scale\n\n\n\n\nResizes the image to fit the specified parameters exactly by scaling the image to the desired size. The aspect ratio of the image is not respected and the image can be distorted using this method.\n\n\n\n\nfit:max\n\n\n\n\nResizes the image to fit within the parameters, but as opposed to 'fit:clip' will not scale the image if the image is smaller than the output size.\n\n\n\n\n\n\n\n\n\n\n\nresize=align:center, top, bottom, left, right, or faces\n\n\n\n\nCan be abbreviated as \na:top\n\n\nUsing align, you can choose the area of the image to focus on. Possible values:\n\nalign:center\n \nalign:top\n \nalign:bottom\n \nalign:left\n \nalign:right\n \nalign:faces\n\n\nBy default, it crops from the center.\nYou can also specify pairs e.g. align:[top,left]. Center cannot be used in pairs.\n\n\n\n\n\n\n\n\n\n\n\nExample with \nresize\n + \nfit:crop\n\n\nhttps://media.graphcms.com/resize=w:300,h:300,fit:crop/bYbYJmGyQfynUBaBkRnP\n\n\n\n\n\n\nCrop\n#\n\n\nCropping is done by entering coordinates for where the boundary of the crop will be.\n\n\nCrop\n \nTask\n \nURL\n \nFormat\n:\n\n\nhttps\n:\n//media.graphcms.com/crop=[options]/[File Handle]\n\n\n\n\n\n\n\n\ncrop=dim:[x,y,width,height]\n\n\n\n\nCan be abbreviated as \nd:[10,20,200,250]\n\n\nCrops the image to a specified rectangle.\n\n\nThe input for this parameter must be exactly 4 integers: \nx coordinate, y coordinate, width, height\n. For example, an input of \ncrop=dim:[10,20,200,250]\n selects a 200x250 pixel rectangle starting 10 pixels from the left edge of the image and 20 pixels from the top edge of the image.\n\n\n\n\n\n\nHow cropping works\n#\n\n\nThe X and Y coordinates start from [0,0] and correspond to the top left hand corner of the image to be cropped. The Width and Height parameters dictate the size in pixels of the cropping rectangle once the point to start the crop at is selected by the X and Y coordinates. If you set coordinates that create a crop area that extends outside the frame of the image, then you will only receive back the part of the image that is within the crop area.\n\n\n\n\n\n\n\nCropping Example\n\n\nOriginal Image:\n\nhttps://media.graphcms.com/resize=w:500/bXa8m7oYQdmyWpmo2I2B\n\n\n\n\nCropped Image\n\nhttps://media.graphcms.com/crop=dim:[2000,900,1800,1300]/resize=w:500/bXa8m7oYQdmyWpmo2I2B\n\n\n\n\n\n\nChaining Transformations\n#\n\n\nThe transformation engine also supports task chaining. This allows you to apply multiple transformations on an image. This is simply done by seperating transformations with a \n/\n.\n\n\nURL\n \nformat\n \nfor\n \nchaining\n:\n\n\nhttps\n:\n//media.graphcms.com/[task]=[options]/[task]=[options]/[File Handle]", 
            "title": "Media"
        }, 
        {
            "location": "/Media/#media", 
            "text": "Working with media is an essential part of content management. GraphCMS allows you to upload and assign media files to any content model in your project. The uploaded files will be assigned to the project\u00b4s internal  Media  model.  Media fields  will then connect the dots between a content model and assigned files.  Media files that are stored in GraphCMS are served via a global content delivery network. This assures quick response times and fast loading of your media.", 
            "title": "Media"
        }, 
        {
            "location": "/Media/#querying-a-media-field", 
            "text": "Uploaded media files can be queried from your content API. Let\u00b4s assume we have a content model  Post , with a field configuration of:   Title  #title   Single Line Text  Images  #images   Media   Allow Multiple Values   This will allow us to store an arbitrary number of images for a  Post .  We can fetch  allPosts  with the following query:  {\n  allPosts {\n    title\n    images {\n      fileName\n      handle\n      url\n      mimeType\n      size\n    }\n  }\n}  Which will give us a result like this:  {\n   data : {\n     allPosts : [\n      {\n         title :  Some nice post ,\n         images : [\n          {\n             fileName :  pexels-photo-295821.jpeg ,\n             handle :  7AmzJToStuJrNqkpPSWO \n             url :  https://media.graphcms.com/7AmzJToStuJrNqkpPSWO ,\n             mimeType :  image/jpeg ,\n             size : 100075,\n          }\n        ]\n      }\n    ]\n  }\n}  Field  #images  will return an array of media objects, which contain the fields:   fileName  the original file name of the uploaded file  handle  the identifier of the uploaded file  url  the full URL to the uploaded file  mimeType  the media type of the uploaded file  size  the total size in bytes    If you know the desired display size of your images, it is highly recommended to use our integrated image transformation engine to scale your images to the desired size. This will increase the loading time of your content and result in a better user experience for your visitors.", 
            "title": "Querying a Media Field"
        }, 
        {
            "location": "/Media/#graphcms-image-transformations", 
            "text": "An essential feature of GraphCMS is the image processing engine. It enables you on the fly image transformations, such as resizing or cropping just by adding parameters to your media\u00b4s URL.", 
            "title": "GraphCMS Image Transformations"
        }, 
        {
            "location": "/Media/#transformation-url-structure-with-graphcms-handle", 
            "text": "https://media.graphcms.com/[(1) Transformation Tasks]/[(2) File Handle]  1) One or multiple transformation tasks and their parameters  2) The source image to run the transformation tasks on.", 
            "title": "Transformation URL Structure with GraphCMS Handle"
        }, 
        {
            "location": "/Media/#available-transformations", 
            "text": "An overview of supported image transformations.   The maximum accepted image size is 100.000.000 pixels. An image with this many pixels could have width and height combinations like 10.000 x 10.000 or 5.000 x 20.000, etc. The maximum file size of an image can not be larger than 256mb.", 
            "title": "Available Transformations"
        }, 
        {
            "location": "/Media/#resize-fit-and-align", 
            "text": "The resizing feature comprises two main functions, manipulating the width and height of an image and changing the fit and alignment of the image.  Resize   Task   URL   Format :  https : //media.graphcms.com/resize=[options]/[File Handle]    Basic resize example with a GraphCMS file handle  https://media.graphcms.com/resize=width:300/bYbYJmGyQfynUBaBkRnP      resize=width:100   Can be abbreviated as  w:100  The width in pixels to resize the image to. The value must be an integer from 1 to 10000.      resize=height:100   Can be abbreviated as  h:100  The height in pixels to resize the image to. The value must be an integer from 1 to 10000.      resize=fit:clip, crop, scale, or max   Can be abbreviated as  f:clip  The default value for the fit parameter is  fit:clip .   fit:clip   Resizes the image to fit within the specified parameters without distorting, cropping, or changing the aspect ratio.   fit:crop   Resizes the image to fit the specified parameters exactly by removing any parts of the image that don't fit within the boundaries.   fit:scale   Resizes the image to fit the specified parameters exactly by scaling the image to the desired size. The aspect ratio of the image is not respected and the image can be distorted using this method.   fit:max   Resizes the image to fit within the parameters, but as opposed to 'fit:clip' will not scale the image if the image is smaller than the output size.      resize=align:center, top, bottom, left, right, or faces   Can be abbreviated as  a:top  Using align, you can choose the area of the image to focus on. Possible values: align:center   align:top   align:bottom   align:left   align:right   align:faces  By default, it crops from the center.\nYou can also specify pairs e.g. align:[top,left]. Center cannot be used in pairs.      Example with  resize  +  fit:crop  https://media.graphcms.com/resize=w:300,h:300,fit:crop/bYbYJmGyQfynUBaBkRnP", 
            "title": "Resize Fit and Align"
        }, 
        {
            "location": "/Media/#crop", 
            "text": "Cropping is done by entering coordinates for where the boundary of the crop will be.  Crop   Task   URL   Format :  https : //media.graphcms.com/crop=[options]/[File Handle]    crop=dim:[x,y,width,height]   Can be abbreviated as  d:[10,20,200,250]  Crops the image to a specified rectangle.  The input for this parameter must be exactly 4 integers:  x coordinate, y coordinate, width, height . For example, an input of  crop=dim:[10,20,200,250]  selects a 200x250 pixel rectangle starting 10 pixels from the left edge of the image and 20 pixels from the top edge of the image.", 
            "title": "Crop"
        }, 
        {
            "location": "/Media/#how-cropping-works", 
            "text": "The X and Y coordinates start from [0,0] and correspond to the top left hand corner of the image to be cropped. The Width and Height parameters dictate the size in pixels of the cropping rectangle once the point to start the crop at is selected by the X and Y coordinates. If you set coordinates that create a crop area that extends outside the frame of the image, then you will only receive back the part of the image that is within the crop area.    Cropping Example  Original Image: https://media.graphcms.com/resize=w:500/bXa8m7oYQdmyWpmo2I2B   Cropped Image https://media.graphcms.com/crop=dim:[2000,900,1800,1300]/resize=w:500/bXa8m7oYQdmyWpmo2I2B", 
            "title": "How cropping works"
        }, 
        {
            "location": "/Media/#chaining-transformations", 
            "text": "The transformation engine also supports task chaining. This allows you to apply multiple transformations on an image. This is simply done by seperating transformations with a  / .  URL   format   for   chaining :  https : //media.graphcms.com/[task]=[options]/[task]=[options]/[File Handle]", 
            "title": "Chaining Transformations"
        }, 
        {
            "location": "/examples/Server-side_rendered_app_with_nextjs_and_apollo/", 
            "text": "Example 01: Server-side Rendered App with Next.js and Apollo\n#\n\n\n\ud83d\ude80 \nLive Demo\n\n\nIn this example we are going to build a simple server-side rendered Application backed by GraphCMS using \nNext.js\n and \nApollo\n. You can find the code in the example\u00b4s \nGitHub repository\n.\n\n\nThe app will be a simple collection of music record reviews. The data model will look as follows:\n\n\n\n\nEach \nReview\n belongs to a \nRecord\n\n\nA \nRecord\n has a list of \nTracks\n\n\nAn \nArtist\n has multiple \nRecords\n\n\n\n\nThe figure below shows the relations and fields of the four models:\n\n\n\n\nSetting up the content models in GraphCMS\n#\n\n\n\n\nIf you haven\u00b4t set up a content model yet, please check our \nGetting Started Guide\n. The project from the guide will be the foundation for this example.\n\n\n\n\nTo set up the models in GraphCMS, we create a new Project named \nVinylbase\n and add our four content models:\n\n\n\n\nThen we add the fields to every content model from the schema above. This should look similar to the screenshots below.\nYou can see the relevant attributes like type, unique constraints etc. below each field name.\n\n\n\n\n\n\n\n\n\n\nAuthorization\n#\n\n\nTo authenticate the app and to be able to fetch data from GraphCMS, we need to create a \npermanent auth token\n. Per default, all content stored in GraphCMS is private, so you cannot fetch data without a valid token outside the GraphCMS web application.\n\n\nTo create a new auth token, go to the settings view and add a token in the auth tokens section.\n\n\n\n\nNow we can start implementing our frontend application.\n\n\nImplementing the app\n#\n\n\n\n\nYou can checkout the source code for this project \nhere\n\n\n\n\nFor the app we will use \nNext.js\n, which is a minimalistic framework for server-rendered React applications.\nData fetching will be done with \nApollo\n, a powerful GraphQL client which runs in nearly any environment.\nApollo allows you to query and mutate your data using plain GraphQL queries. This makes the development process easy since you can test your queries in our integrated api explorer and paste them directly into your project. Apollo manages things like caching, prefetching and optimistic UI.\n\n\nAs a starting point we used \nthis\n project (thanks to \nAdam Soffer\n).\nThis projects is a skeleton for using Apollo within a Next.js application. To allow this, it wraps the pages within a higher order component (\nHOC\n), which will pass down query results from Apollo directly into the component. This is realized by Apollo\u00b4s \ngetDataFromTree\n function, which checks the React tree on which data it needs to be rendered. This function returns a promise when the data is ready in the Apollo Store, so the page can be rendered.\n\n\nSetting up Apollo\n#\n\n\nFirst, we need to init the Apollo client to set the API endpoint and set up authorization. This is done within the \ncreateClient\n function within \n/lib/initClient.js\n.\nHere we use the middleware feature of the Apollo networkInterface by simply adding our token.\n\n\nPlease check the \ndocs\n for more information.\n\n\nfunction\n \ncreateClient\n \n(\nheaders\n)\n \n{\n\n  \nconst\n \nGRAPHCMS_API\n \n=\n \nprocess\n.\nenv\n.\nGRAPHCMS_API\n\n  \nconst\n \nTOKEN\n \n=\n \nprocess\n.\nenv\n.\nTOKEN\n\n\n  \nif\n \n(\n!\nGRAPHCMS_API\n \n||\n \n!\nTOKEN\n)\n \n{\n\n    \nthrow\n \nnew\n \nError\n(\n`Environment variables \nGRAPHCMS_API\n or \nTOKEN\n missing`\n)\n\n  \n}\n\n\n  \nconst\n \nnetworkInterface\n \n=\n \ncreateNetworkInterface\n({\n\n    \nuri\n: \nGRAPHCMS_API\n,\n\n\n    \nops\n:\n \n{\n\n      \ncredentials\n:\n \nsame-origin\n\n    \n}\n\n  \n})\n\n\n  \nnetworkInterface\n.\nuse\n([{\n\n    \napplyMiddleware\n \n(\nreq\n,\n \nnext\n)\n \n{\n\n      \nif\n \n(\n!\nreq\n.\noptions\n.\nheaders\n)\n \n{\n\n        \nreq\n.\noptions\n.\nheaders\n \n=\n \n{}\n\n      \n}\n\n\n      \nreq\n.\noptions\n.\nheaders\n.\nauthorization\n \n=\n \n`Bearer \n${\nTOKEN\n}\n`\n\n      \nnext\n()\n\n    \n}\n\n  \n}])\n\n\n  \nreturn\n \nnew\n \nApolloClient\n({\n \nnetworkInterface\n \n})\n\n\n}\n\n\n\n\n\n\nGetting content into the pages\n#\n\n\nTo use Apollo in our content pages, we need to wrap them with the higher order component \nwithData\n defined in \n/lib/withData\n. An example can be seen in the \nindex.js\n file from the \npages\n folder. This is the entry point of the app and will display a grid of reviews.\nTo build the query for the required data, we switch over to the \nAPI-Explorer\n in GraphCMS and choose \"Simple\" as endpoint.\nHere we can write and test our first query to request all existing reviews:\n\n\n\n\nAfter we build the query that works for us, we can copy it into the \nallReviews\n query in the \n/pages/index.js\n file.\nTo initialize Apollo queries, we use the \nreact-apollo\n library which wraps and passes the fetched data into the \nAllReviews\n component. This data will be available as a prop named \ndata\n by default.\nTo ensure that the Apollo data is available here, we need to wrap the component with the \nwithData\n higher order component as discussed before.\n\n\nAn example is shown below:\n\n\nfunction\n \nAllReviews\n \n({\n \nurl\n:\n \n{\n \npathname\n \n},\n \nloading\n,\n \ndata\n:\n \n{\n \nallReviews\n \n}\n \n})\n \n{\n\n  \nreturn\n \n(\n\n    \nApp\n\n      \nNav\n \npathname\n=\n{\npathname\n}\n \n/\n\n      \n{\n\n        \nloading\n \n?\n \nLoading\n \n/\n \n:\n \n(\n\n          \ndiv\n\n            \nHeader\n\n              \ntitle\n=\nVinylbase\n\n              \nsubLine\n=\nThe best music reviews on the interwebs\n\n              \npageImage\n=\n/static/records.svg\n\n              \nisIcon\n\n            \n/\n\n            \nsection\n\n              \nGrid\n \nentries\n=\n{\nallReviews\n}\n \ntype\n=\nreviews\n \n/\n\n            \n/section\n\n          \n/div\n\n        \n)\n\n       \n}\n\n    \n/App\n\n  \n)\n\n\n}\n\n\n\nconst\n \nallReviews\n \n=\n \ngql\n`\n\n\n  query allReviews {\n\n\n    allReviews(orderBy: createdAt_DESC) {\n\n\n      id\n\n\n      slug\n\n\n      createdAt\n\n\n      title\n\n\n    }\n\n\n  }`\n\n\n\nexport\n \ndefault\n \nwithData\n(\ngraphql\n(\nallReviews\n)(\nAllReviews\n))\n\n\n\n\n\n\nThe rest of the app code is pretty straight forward. For every grid view there is a corresponding page within the root\u00b4s \npages\n folder, similar to the example above.\nFor the detail views a \ndetails.js\n is placed within a subfolder.\nTo enable routing to those pages we use the \nslug\n field of each model. This is a URL safe representation of the unique title or name of the model. This allows us to use pretty and SEO friendly URLs for our pages. GraphCMS allows you to define text fields with the appearance \nslug\n. This creates a sluggified representation of your text input. To ensure this value is unique, we have marked those fields as \nunique\n in GraphCMS.\nTo use these slugs for routing, we must define the corresponding routes in the \nserver.js\n file. We use \nExpress\n as a server, which makes routing easy.\n\n\nHere is an example of the route to a review\u00b4s detail page. It takes the slug from the path and passes it into the component as a prop.\n\n\nserver.get(\n/reviews/:slug\n, (req, res) =\n {\n  return app.render(req, res, \n/reviews/details\n, { slug: req.params.slug })\n})\n\n\n\n\n\nTo use this slug in the GraphQL query, we use a $slug variable. Since the slug field is marked as unique in GraphCMS, we can search for it directly by passing it as a parameter to the \nReview\n query.\nTo pass the value into the query, we can use the options object in the Apollo wrapper.\nThis object has an options property, which is a simple function returning the options used by Apollo. The function will receive the props from the router, so we can destructure them to return a variables object, used to set all variables in our query:\n\n\nfunction\n \nReview\n \n({\n \nurl\n:\n \n{\n \npathname\n \n},\n \ndata\n:\n \n{\n \nloading\n,\n \nReview\n \n}\n \n})\n \n{\n\n  \nreturn\n \n(\n\n    \nApp\n\n      \nNav\n \npathname\n=\n{\npathname\n}\n \n/\n\n      \n{\n\n        \nloading\n \n?\n \nLoading\n \n/\n \n:\n \n(\n\n          \ndiv\n\n            \nHeader\n \ntitle\n=\n{\nReview\n.\ntitle\n}\n \n/\n\n            \nReviewDetails\n \nreview\n=\n{\nReview\n}\n \n/\n\n          \n/div\n\n        \n)\n\n       \n}\n\n    \n/App\n\n  \n)\n\n\n}\n\n\n\nconst\n \nreviewDetails\n \n=\n \ngql\n`\n\n\n  query reviewDetails($slug: String! ) {\n\n\n    Review(slug: $slug) {\n\n\n      id\n\n\n      title\n\n\n      review\n\n\n      rating\n\n\n      record {\n\n\n        title\n\n\n        cover {\n\n\n          handle\n\n\n        }\n\n\n        artist {\n\n\n          name\n\n\n          slug\n\n\n        }\n\n\n      }\n\n\n    }\n\n\n}`\n\n\n\nconst\n \nReviewWithData\n \n=\n \ngraphql\n(\nreviewDetails\n,\n \n{\n\n  \noptions\n:\n \n({\n \nurl\n:\n \n{\n \nquery\n:\n \n{\n \nslug\n \n}\n \n}\n \n})\n \n=\n \n({\n \nvariables\n:\n \n{\n \nslug\n \n}\n \n})\n\n\n})(\nReview\n)\n\n\n\nexport\n \ndefault\n(\nwithData\n(\nReviewWithData\n))\n\n\n\n\n\n\nAll other pages are build in a similar way, so we won't describe all of them here. Feel free to browse the code in the \nrepository\n.", 
            "title": "Server-side rendered app with Next.js and Apollo"
        }, 
        {
            "location": "/examples/Server-side_rendered_app_with_nextjs_and_apollo/#example-01-server-side-rendered-app-with-nextjs-and-apollo", 
            "text": "\ud83d\ude80  Live Demo  In this example we are going to build a simple server-side rendered Application backed by GraphCMS using  Next.js  and  Apollo . You can find the code in the example\u00b4s  GitHub repository .  The app will be a simple collection of music record reviews. The data model will look as follows:   Each  Review  belongs to a  Record  A  Record  has a list of  Tracks  An  Artist  has multiple  Records   The figure below shows the relations and fields of the four models:", 
            "title": "Example 01: Server-side Rendered App with Next.js and Apollo"
        }, 
        {
            "location": "/examples/Server-side_rendered_app_with_nextjs_and_apollo/#setting-up-the-content-models-in-graphcms", 
            "text": "If you haven\u00b4t set up a content model yet, please check our  Getting Started Guide . The project from the guide will be the foundation for this example.   To set up the models in GraphCMS, we create a new Project named  Vinylbase  and add our four content models:   Then we add the fields to every content model from the schema above. This should look similar to the screenshots below.\nYou can see the relevant attributes like type, unique constraints etc. below each field name.", 
            "title": "Setting up the content models in GraphCMS"
        }, 
        {
            "location": "/examples/Server-side_rendered_app_with_nextjs_and_apollo/#authorization", 
            "text": "To authenticate the app and to be able to fetch data from GraphCMS, we need to create a  permanent auth token . Per default, all content stored in GraphCMS is private, so you cannot fetch data without a valid token outside the GraphCMS web application.  To create a new auth token, go to the settings view and add a token in the auth tokens section.   Now we can start implementing our frontend application.", 
            "title": "Authorization"
        }, 
        {
            "location": "/examples/Server-side_rendered_app_with_nextjs_and_apollo/#implementing-the-app", 
            "text": "You can checkout the source code for this project  here   For the app we will use  Next.js , which is a minimalistic framework for server-rendered React applications.\nData fetching will be done with  Apollo , a powerful GraphQL client which runs in nearly any environment.\nApollo allows you to query and mutate your data using plain GraphQL queries. This makes the development process easy since you can test your queries in our integrated api explorer and paste them directly into your project. Apollo manages things like caching, prefetching and optimistic UI.  As a starting point we used  this  project (thanks to  Adam Soffer ).\nThis projects is a skeleton for using Apollo within a Next.js application. To allow this, it wraps the pages within a higher order component ( HOC ), which will pass down query results from Apollo directly into the component. This is realized by Apollo\u00b4s  getDataFromTree  function, which checks the React tree on which data it needs to be rendered. This function returns a promise when the data is ready in the Apollo Store, so the page can be rendered.", 
            "title": "Implementing the app"
        }, 
        {
            "location": "/examples/Server-side_rendered_app_with_nextjs_and_apollo/#setting-up-apollo", 
            "text": "First, we need to init the Apollo client to set the API endpoint and set up authorization. This is done within the  createClient  function within  /lib/initClient.js .\nHere we use the middleware feature of the Apollo networkInterface by simply adding our token.  Please check the  docs  for more information.  function   createClient   ( headers )   { \n   const   GRAPHCMS_API   =   process . env . GRAPHCMS_API \n   const   TOKEN   =   process . env . TOKEN \n\n   if   ( ! GRAPHCMS_API   ||   ! TOKEN )   { \n     throw   new   Error ( `Environment variables  GRAPHCMS_API  or  TOKEN  missing` ) \n   } \n\n   const   networkInterface   =   createNetworkInterface ({ \n     uri :  GRAPHCMS_API , \n\n     ops :   { \n       credentials :   same-origin \n     } \n   }) \n\n   networkInterface . use ([{ \n     applyMiddleware   ( req ,   next )   { \n       if   ( ! req . options . headers )   { \n         req . options . headers   =   {} \n       } \n\n       req . options . headers . authorization   =   `Bearer  ${ TOKEN } ` \n       next () \n     } \n   }]) \n\n   return   new   ApolloClient ({   networkInterface   })  }", 
            "title": "Setting up Apollo"
        }, 
        {
            "location": "/examples/Server-side_rendered_app_with_nextjs_and_apollo/#getting-content-into-the-pages", 
            "text": "To use Apollo in our content pages, we need to wrap them with the higher order component  withData  defined in  /lib/withData . An example can be seen in the  index.js  file from the  pages  folder. This is the entry point of the app and will display a grid of reviews.\nTo build the query for the required data, we switch over to the  API-Explorer  in GraphCMS and choose \"Simple\" as endpoint.\nHere we can write and test our first query to request all existing reviews:   After we build the query that works for us, we can copy it into the  allReviews  query in the  /pages/index.js  file.\nTo initialize Apollo queries, we use the  react-apollo  library which wraps and passes the fetched data into the  AllReviews  component. This data will be available as a prop named  data  by default.\nTo ensure that the Apollo data is available here, we need to wrap the component with the  withData  higher order component as discussed before.  An example is shown below:  function   AllReviews   ({   url :   {   pathname   },   loading ,   data :   {   allReviews   }   })   { \n   return   ( \n     App \n       Nav   pathname = { pathname }   / \n       { \n         loading   ?   Loading   /   :   ( \n           div \n             Header \n               title = Vinylbase \n               subLine = The best music reviews on the interwebs \n               pageImage = /static/records.svg \n               isIcon \n             / \n             section \n               Grid   entries = { allReviews }   type = reviews   / \n             /section \n           /div \n         ) \n        } \n     /App \n   )  }  const   allReviews   =   gql `    query allReviews {      allReviews(orderBy: createdAt_DESC) {        id        slug        createdAt        title      }    }`  export   default   withData ( graphql ( allReviews )( AllReviews ))   The rest of the app code is pretty straight forward. For every grid view there is a corresponding page within the root\u00b4s  pages  folder, similar to the example above.\nFor the detail views a  details.js  is placed within a subfolder.\nTo enable routing to those pages we use the  slug  field of each model. This is a URL safe representation of the unique title or name of the model. This allows us to use pretty and SEO friendly URLs for our pages. GraphCMS allows you to define text fields with the appearance  slug . This creates a sluggified representation of your text input. To ensure this value is unique, we have marked those fields as  unique  in GraphCMS.\nTo use these slugs for routing, we must define the corresponding routes in the  server.js  file. We use  Express  as a server, which makes routing easy.  Here is an example of the route to a review\u00b4s detail page. It takes the slug from the path and passes it into the component as a prop.  server.get( /reviews/:slug , (req, res) =  {\n  return app.render(req, res,  /reviews/details , { slug: req.params.slug })\n})  To use this slug in the GraphQL query, we use a $slug variable. Since the slug field is marked as unique in GraphCMS, we can search for it directly by passing it as a parameter to the  Review  query.\nTo pass the value into the query, we can use the options object in the Apollo wrapper.\nThis object has an options property, which is a simple function returning the options used by Apollo. The function will receive the props from the router, so we can destructure them to return a variables object, used to set all variables in our query:  function   Review   ({   url :   {   pathname   },   data :   {   loading ,   Review   }   })   { \n   return   ( \n     App \n       Nav   pathname = { pathname }   / \n       { \n         loading   ?   Loading   /   :   ( \n           div \n             Header   title = { Review . title }   / \n             ReviewDetails   review = { Review }   / \n           /div \n         ) \n        } \n     /App \n   )  }  const   reviewDetails   =   gql `    query reviewDetails($slug: String! ) {      Review(slug: $slug) {        id        title        review        rating        record {          title          cover {            handle          }          artist {            name            slug          }        }      }  }`  const   ReviewWithData   =   graphql ( reviewDetails ,   { \n   options :   ({   url :   {   query :   {   slug   }   }   })   =   ({   variables :   {   slug   }   })  })( Review )  export   default ( withData ( ReviewWithData ))   All other pages are build in a similar way, so we won't describe all of them here. Feel free to browse the code in the  repository .", 
            "title": "Getting content into the pages"
        }, 
        {
            "location": "/API_simple/", 
            "text": "Simple API\n#\n\n\nGraphCMS provides two different APIs for you: \nRelay\n and \nSimple\n.\nWhich one you choose is up to you and depends on your use case. The simple API is less complex, in comparison to the Relay API. If you don't use \nFacebook's Relay\n it might be simpler to start with the Simple API.\nOf course it is up to you which one you prefer. You might also use both APIs inside your app if you want to.\n\n\nQuerying the API\n#\n\n\nTo query the Simple API you need to use your project specific Endpoint URL. The URL is composed by the API URL and your project ID:\n\n\nhttps://api.graphcms.com/simple/v1/$YOUR_PROJECT_ID$\n\n\nThis URL can be used by clients like Apollo, Lokka or simple curl-request.\nFor example if you wan't to query the title of all posts within your project you could use the following curl command:\n\n\ncurl 'https://api.graphcms.com/simple/v1/$YOUR_PROJECT_ID$' -H 'content-type: application/json' --data-binary '{\"query\":\"query {allPosts {title}}\"}' --compressed\n\n\nGenerated Queries\n#\n\n\nUsing \nqueries\n you can ask for data you are interested in. Within each query you define a set of fields, which should be returned within the response.\nAll queries are generated for you and can have different arguments which can be passed into the query.\n\n\nQuery a single entry\n#\n\n\nFor every content model there is one query to fetch a specific entry. You have to pass a selector as an argument to this query, to retrieve the right entry.\nYou can either pass the entries ID or any scalar field which is marked as \nunique\n within this model.\nFor example if you wan't to get the \nname\n and the \ncreatedAt\n field from the content model \nArtist\n, the following request can be used:\n\n\nquery {\n  Article(\n    id: \ncixnen2vv33lo0143bdwvr52n\n\n  ) {\n    name\n    createdAt\n  }\n}\n\n\n\n\n\nOr, if the Artist model has a unique field \nslug\n:\n\n\nquery {\n  Artist(\n    slug: \nmy-awesome-artist\n\n  ) {\n    name\n    createdAt\n  }\n}\n\n\n\n\n\n\n\nYou cannot use both parameters within one query\n\n\n\n\nQuery multiple entries\n#\n\n\nThe Simple API contains automatically generated queries to fetch all entries of a certain model. For example, for the Artist model the top-level query allArtists will be generated.\n\n\nA few examples for query names\n- model name: Artist, query name: allArtists\n- model name: Track, query name: allTracks\n- model name: Review, query name: allReviews.\n\n\nA query which fetches all entries from the \nArtist\n content model could look like the following:\n\n\nquery {\n  allArtists {\n    id\n    name\n  }\n}\n\n\n\n\n\n\n\nNote: The query name approximates the plural rules of the English language. If you are unsure about the actual query name, explore available queries in your API EXPLORER.\n\n\n\n\nThe query response of a query fetching multiple entries can be further controlled by supplying different query arguments. The response can be \nordered\n, \nfiltered\n or \npaginated\n\n\nOrdering entries\n#\n\n\nWhen querying all entries of a model you can supply the orderBy argument for every scalar field of the model:\n\norderBy: \nfield\n_ASC\n or \norderBy: \nfield\n_DESC.\n\n\nExample:\n\n\nquery {\n  allArtists(\n    orderBy: name_ASC\n  ) {\n    id\n    name\n  }\n}\n\n\n\n\n\nFiltering entries\n#\n\n\nWhen querying all entries of a model you can supply different parameters to the filter argument to filter the query response accordingly. The available options depend on the scalar fields defined on the model in question.\n\n\nIf you supply exactly one parameter to the filter argument, the query response will only contain entries that fulfill this constraint:\n\n\nquery {\n  allArtists(\n    filter: {\n      published: false\n    }\n  ) {\n    id\n    name\n    published\n  }\n}\n\n\n\n\n\nDepending on the type of the field you want to filter by, you have access to different advanced criteria you can use to filter your query response:\n\n\nallArtists(\n  filter: {\n    name_in: [\n      \nVelvet Parker\n,\n      \nCat Stevie\n\n    ]\n  }\n) {\n  id\n  name\n  published\n}\n}\n\n\n\n\n\nFor to-one relations, you can define conditions on the related entry by nesting the according argument in filter:\n\n\n{\n  allRecords(filter: {artist: {name: \nCat-Stevie\n}}) {\n    id\n    slug\n  }\n}\n\n\n\n\n\nFor to-many relations, three additional arguments are available: \nevery\n, \nsome\n and \nnone\n, to define that a condition should match every, some or none related entries.\n\n\nquery {\n  {\n    allArtists(filter: {records_every: {slug: \nAll-your-Base\n}}) {\n      id\n      name\n    }\n  }\n}\n\n\n\n\n\nYou can use the filter combinators \nOR\n and \nAND\n to create an arbitrary logical combination of filter conditions.\n\n\n{\n  allRecords(filter: {AND: [{artist: {name: \nCat-Stevie\n}}, {cover: {isPublic: true}}]}) {\n    id\n    slug\n    cover {\n      url\n    }\n  }\n}\n\n\n\n\n\nYou can combine and even nest the filter combinators \nAND\n and \nOR\n to create arbitrary logical combinations of filter conditions:\n\n\n{\n  allRecords(filter: {OR: [\n    {AND: [{artist: {name: \nCat-Stevie\n}}, {cover: {isPublic: true}}]},\n    {OR: [{artist: {name_not: \nCat-Stevie\n}}, {cover: {isPublic: false}}]}\n  ]}) {\n    id\n    slug\n    cover {\n      url\n    }\n  }\n}\n\n\n\n\n\nPagination\n#\n\n\nWhen querying all entries of a specific model you can supply arguments that allow you to paginate the query response.\nPagination allows you to request a certain amount of entries at the same time. You can seek forwards or backwards through the entries and supply an optional starting entry:\n\n\n\n\nto seek forwards, use \nfirst\n; specify a starting entry with after.\n\n\nto seek backwards, use \nlast\n; specify a starting entry with before.\n\n\n\n\nYou can also skip an arbitrary amount of entries in whichever direction you are seeking by supplying the skip argument:\n\n\n{\n  allArtists(first: 5) {\n    id\n    name\n  }\n}\n\n\n\n\n\nTo query the first two articles after the first article with id \ncixnen2ssewlo0143bexdd52n\n:\n\n\nquery {\n  allArticles(\n    first: 2,\n    after: \ncixnen2ssewlo0143bexdd52n\n\n  ) {\n    id\n    name\n  }\n}\n\n\n\n\n\nTo query the last 5 articles use \nlast\n:\n\n\nquery {\n  allArticles(last: 5) {\n    id\n    name\n  }\n}\n\n\n\n\n\n\n\nNote: You cannot combine first with before or last with after. Note: If you query more entries than exist, your response will simply contain all entries that actually do exist in that direction.\n\n\n\n\nGenerated mutations\n#\n\n\nWith a mutation you can modify the data of your project. Similar to queries, all mutations are automatically generated. Explore them by using the API EXPLORER inside your project.\nThis is an example mutation:\n\n\nmutation {\n  createArtist(name:\nCat Stevie\n slug:\ncat-stevie\n) {\n    id\n    name\n    slug\n  }\n}\n\n\n\n\n\n\n\nNote: The subselection of fields cannot be empty. If you have no specific data requirements, you can always select id as a default.\n\n\n\n\nModifying entries\n#\n\n\nFor every content model in your project, there are different mutations to create, update and delete entries.\n\n\nCreating entries\n#\n\n\nCreates a new entry for a specific model that gets assigned a new id. All required fields of the model without a default value have to be specified, the other fields are optional arguments.\nThe query response can contain all fields of the newly created entry, including the id field.\n\n\nmutation {\n  createArtist(name:\nCat Stevie\n slug:\ncat-stevie\n) {\n    id\n    name\n    slug\n  }\n}\n\n\n\n\n\nWhen creating an entry you can directly connect it to another entry on the one-side of a relation. You can either choose to connect it to an existing entry, or even create the entry yourself:\n\n\nmutation {\n  createArtist(name: \nCat Stevie\n, slug: \ncat-stevie\n, records: [{title: \nSummer Breeze\n, slug: \nsummer-breeze\n}]) {\n    id\n    name\n    slug\n  }\n}\n\n\n\n\n\n\n\nNote: This works for one-to-one and one-to-many relations but not for many-to-many relations.\n\n\n\n\nUpdating entries\n#\n\n\nUpdates fields of an existing entry of a certain content model specified by the id field. The entry's fields will be updated according to the additionally provided values.\nThe query response can contain all fields of the updated entry.\n\n\nmutation {\n  updateArtist(id:\ncixnen2ssewlo0143bexdd52n\n slug:\ncat-stevie\n) {\n    id\n    slug\n  }\n}\n\n\n\n\n\nDeleting entries\n#\n\n\nDeletes an entry specified by the id field.\nThe query response can contain all fields of the deleted entry.\n\n\nmutation {\n  deleteArtist(id:\ncixnen2ssewlo0143bexdd52n\n) {\n    id\n  }\n}\n\n\n\n\n\nConnect two entries in a one-to-one relation\n#\n\n\nCreates a new edge between two entries specified by their id. The according models have to be in the same relation.\nThe query response can contain both entries of the new edge. The names of query arguments and entry names depend on the field names of the relation.\n\n\nmutation {\n    setArtistReview(reviewReviewId:\ncixnen2ssewlo0143bexdd52n\n artistArtistId:\ncixnen2sse223412bexdd52n\n) {\n    artistArtist {\n      id\n      name\n    }\n    reviewReview {\n      id\n      title\n    }\n  }\n}\n\n\n\n\n\n\n\nNote: First removes existing connections containing one of the specified entries, then adds the edge connecting both entries.\n\n\n\n\nYou can also use the \nupdateArtist\n or \nupdateReview\n to connect an artist with a review:\n\n\nmutation {\n  updateArtist(id: \ncixnen2sse223412bexdd52n\n, reviewId: \ncixnen2ssewlo0143bexdd52n\n) {\n    id\n  }\n}\n\n\n\n\n\nTo removes an edge of an entry you have can use the \nunset\n mutation.\nThe query response can contain both entries of the former edge. The names of query arguments and entry names depend on the field names of the relation:\n\n\nmutation {\n  unsetArtistReview(reviewReviewId: \ncixnen2ssewlo0143bexdd52n\n, artistArtistId: \ncixnen2sse223412bexdd52n\n) {\n    artistArtist {\n      id\n    }\n    reviewReview {\n      id\n    }\n  }\n}\n\n\n\n\n\nConnect two entries in a one-to-many relation\n#\n\n\nOne-to-many relations relate two models to each other.\nAn entry of the one side of a one-to-many relation can be connected to multiple entries. An entry of the many side of a one-to-many relation can at most be connected to one entry.\n\n\nTo creates a new edge between two entries you have to use the \naddTo\n mutation. The according models have to be in the same relation.\nThe query response can contain both entries of the new edge. The names of query arguments and entry names depend on the field names of the relation.\n\n\nmutation {\n  addToTrackList(tracksTrackId: \ncixnen2sddseq143bexdd52n\n, recordRecordId: \ncixnen222dfsdwebexdd52n\n) {\n    recordRecord {\n      id\n    }\n    tracksTrack {\n      id\n    }\n  }\n}\n\n\n\n\n\nTo remove one edge between two entries use the \nremoveFrom\n mutation.\nThe query response can contain both entries of the former edge. The names of query arguments and entry names depend on the field names of the relation.\n\n\nmutation {\n  removeFromTrackList(tracksTrackId: \ncixnen2sddseq143bexdd52n\n, recordRecordId: \ncixnen222dfsdwebexdd52n\n) {\n    recordRecord {\n      id\n    }\n    tracksTrack {\n      id\n    }\n  }\n}\n\n\n\n\n\n\n\nAPI docs are provided by GRAPHCOOL", 
            "title": "Simple"
        }, 
        {
            "location": "/API_simple/#simple-api", 
            "text": "GraphCMS provides two different APIs for you:  Relay  and  Simple .\nWhich one you choose is up to you and depends on your use case. The simple API is less complex, in comparison to the Relay API. If you don't use  Facebook's Relay  it might be simpler to start with the Simple API.\nOf course it is up to you which one you prefer. You might also use both APIs inside your app if you want to.", 
            "title": "Simple API"
        }, 
        {
            "location": "/API_simple/#querying-the-api", 
            "text": "To query the Simple API you need to use your project specific Endpoint URL. The URL is composed by the API URL and your project ID:  https://api.graphcms.com/simple/v1/$YOUR_PROJECT_ID$  This URL can be used by clients like Apollo, Lokka or simple curl-request.\nFor example if you wan't to query the title of all posts within your project you could use the following curl command:  curl 'https://api.graphcms.com/simple/v1/$YOUR_PROJECT_ID$' -H 'content-type: application/json' --data-binary '{\"query\":\"query {allPosts {title}}\"}' --compressed", 
            "title": "Querying the API"
        }, 
        {
            "location": "/API_simple/#generated-queries", 
            "text": "Using  queries  you can ask for data you are interested in. Within each query you define a set of fields, which should be returned within the response.\nAll queries are generated for you and can have different arguments which can be passed into the query.", 
            "title": "Generated Queries"
        }, 
        {
            "location": "/API_simple/#query-a-single-entry", 
            "text": "For every content model there is one query to fetch a specific entry. You have to pass a selector as an argument to this query, to retrieve the right entry.\nYou can either pass the entries ID or any scalar field which is marked as  unique  within this model.\nFor example if you wan't to get the  name  and the  createdAt  field from the content model  Artist , the following request can be used:  query {\n  Article(\n    id:  cixnen2vv33lo0143bdwvr52n \n  ) {\n    name\n    createdAt\n  }\n}  Or, if the Artist model has a unique field  slug :  query {\n  Artist(\n    slug:  my-awesome-artist \n  ) {\n    name\n    createdAt\n  }\n}   You cannot use both parameters within one query", 
            "title": "Query a single entry"
        }, 
        {
            "location": "/API_simple/#query-multiple-entries", 
            "text": "The Simple API contains automatically generated queries to fetch all entries of a certain model. For example, for the Artist model the top-level query allArtists will be generated.  A few examples for query names\n- model name: Artist, query name: allArtists\n- model name: Track, query name: allTracks\n- model name: Review, query name: allReviews.  A query which fetches all entries from the  Artist  content model could look like the following:  query {\n  allArtists {\n    id\n    name\n  }\n}   Note: The query name approximates the plural rules of the English language. If you are unsure about the actual query name, explore available queries in your API EXPLORER.   The query response of a query fetching multiple entries can be further controlled by supplying different query arguments. The response can be  ordered ,  filtered  or  paginated", 
            "title": "Query multiple entries"
        }, 
        {
            "location": "/API_simple/#ordering-entries", 
            "text": "When querying all entries of a model you can supply the orderBy argument for every scalar field of the model: orderBy:  field _ASC  or  orderBy:  field _DESC.  Example:  query {\n  allArtists(\n    orderBy: name_ASC\n  ) {\n    id\n    name\n  }\n}", 
            "title": "Ordering entries"
        }, 
        {
            "location": "/API_simple/#filtering-entries", 
            "text": "When querying all entries of a model you can supply different parameters to the filter argument to filter the query response accordingly. The available options depend on the scalar fields defined on the model in question.  If you supply exactly one parameter to the filter argument, the query response will only contain entries that fulfill this constraint:  query {\n  allArtists(\n    filter: {\n      published: false\n    }\n  ) {\n    id\n    name\n    published\n  }\n}  Depending on the type of the field you want to filter by, you have access to different advanced criteria you can use to filter your query response:  allArtists(\n  filter: {\n    name_in: [\n       Velvet Parker ,\n       Cat Stevie \n    ]\n  }\n) {\n  id\n  name\n  published\n}\n}  For to-one relations, you can define conditions on the related entry by nesting the according argument in filter:  {\n  allRecords(filter: {artist: {name:  Cat-Stevie }}) {\n    id\n    slug\n  }\n}  For to-many relations, three additional arguments are available:  every ,  some  and  none , to define that a condition should match every, some or none related entries.  query {\n  {\n    allArtists(filter: {records_every: {slug:  All-your-Base }}) {\n      id\n      name\n    }\n  }\n}  You can use the filter combinators  OR  and  AND  to create an arbitrary logical combination of filter conditions.  {\n  allRecords(filter: {AND: [{artist: {name:  Cat-Stevie }}, {cover: {isPublic: true}}]}) {\n    id\n    slug\n    cover {\n      url\n    }\n  }\n}  You can combine and even nest the filter combinators  AND  and  OR  to create arbitrary logical combinations of filter conditions:  {\n  allRecords(filter: {OR: [\n    {AND: [{artist: {name:  Cat-Stevie }}, {cover: {isPublic: true}}]},\n    {OR: [{artist: {name_not:  Cat-Stevie }}, {cover: {isPublic: false}}]}\n  ]}) {\n    id\n    slug\n    cover {\n      url\n    }\n  }\n}", 
            "title": "Filtering entries"
        }, 
        {
            "location": "/API_simple/#pagination", 
            "text": "When querying all entries of a specific model you can supply arguments that allow you to paginate the query response.\nPagination allows you to request a certain amount of entries at the same time. You can seek forwards or backwards through the entries and supply an optional starting entry:   to seek forwards, use  first ; specify a starting entry with after.  to seek backwards, use  last ; specify a starting entry with before.   You can also skip an arbitrary amount of entries in whichever direction you are seeking by supplying the skip argument:  {\n  allArtists(first: 5) {\n    id\n    name\n  }\n}  To query the first two articles after the first article with id  cixnen2ssewlo0143bexdd52n :  query {\n  allArticles(\n    first: 2,\n    after:  cixnen2ssewlo0143bexdd52n \n  ) {\n    id\n    name\n  }\n}  To query the last 5 articles use  last :  query {\n  allArticles(last: 5) {\n    id\n    name\n  }\n}   Note: You cannot combine first with before or last with after. Note: If you query more entries than exist, your response will simply contain all entries that actually do exist in that direction.", 
            "title": "Pagination"
        }, 
        {
            "location": "/API_simple/#generated-mutations", 
            "text": "With a mutation you can modify the data of your project. Similar to queries, all mutations are automatically generated. Explore them by using the API EXPLORER inside your project.\nThis is an example mutation:  mutation {\n  createArtist(name: Cat Stevie  slug: cat-stevie ) {\n    id\n    name\n    slug\n  }\n}   Note: The subselection of fields cannot be empty. If you have no specific data requirements, you can always select id as a default.", 
            "title": "Generated mutations"
        }, 
        {
            "location": "/API_simple/#modifying-entries", 
            "text": "For every content model in your project, there are different mutations to create, update and delete entries.", 
            "title": "Modifying entries"
        }, 
        {
            "location": "/API_simple/#creating-entries", 
            "text": "Creates a new entry for a specific model that gets assigned a new id. All required fields of the model without a default value have to be specified, the other fields are optional arguments.\nThe query response can contain all fields of the newly created entry, including the id field.  mutation {\n  createArtist(name: Cat Stevie  slug: cat-stevie ) {\n    id\n    name\n    slug\n  }\n}  When creating an entry you can directly connect it to another entry on the one-side of a relation. You can either choose to connect it to an existing entry, or even create the entry yourself:  mutation {\n  createArtist(name:  Cat Stevie , slug:  cat-stevie , records: [{title:  Summer Breeze , slug:  summer-breeze }]) {\n    id\n    name\n    slug\n  }\n}   Note: This works for one-to-one and one-to-many relations but not for many-to-many relations.", 
            "title": "Creating entries"
        }, 
        {
            "location": "/API_simple/#updating-entries", 
            "text": "Updates fields of an existing entry of a certain content model specified by the id field. The entry's fields will be updated according to the additionally provided values.\nThe query response can contain all fields of the updated entry.  mutation {\n  updateArtist(id: cixnen2ssewlo0143bexdd52n  slug: cat-stevie ) {\n    id\n    slug\n  }\n}", 
            "title": "Updating entries"
        }, 
        {
            "location": "/API_simple/#deleting-entries", 
            "text": "Deletes an entry specified by the id field.\nThe query response can contain all fields of the deleted entry.  mutation {\n  deleteArtist(id: cixnen2ssewlo0143bexdd52n ) {\n    id\n  }\n}", 
            "title": "Deleting entries"
        }, 
        {
            "location": "/API_simple/#connect-two-entries-in-a-one-to-one-relation", 
            "text": "Creates a new edge between two entries specified by their id. The according models have to be in the same relation.\nThe query response can contain both entries of the new edge. The names of query arguments and entry names depend on the field names of the relation.  mutation {\n    setArtistReview(reviewReviewId: cixnen2ssewlo0143bexdd52n  artistArtistId: cixnen2sse223412bexdd52n ) {\n    artistArtist {\n      id\n      name\n    }\n    reviewReview {\n      id\n      title\n    }\n  }\n}   Note: First removes existing connections containing one of the specified entries, then adds the edge connecting both entries.   You can also use the  updateArtist  or  updateReview  to connect an artist with a review:  mutation {\n  updateArtist(id:  cixnen2sse223412bexdd52n , reviewId:  cixnen2ssewlo0143bexdd52n ) {\n    id\n  }\n}  To removes an edge of an entry you have can use the  unset  mutation.\nThe query response can contain both entries of the former edge. The names of query arguments and entry names depend on the field names of the relation:  mutation {\n  unsetArtistReview(reviewReviewId:  cixnen2ssewlo0143bexdd52n , artistArtistId:  cixnen2sse223412bexdd52n ) {\n    artistArtist {\n      id\n    }\n    reviewReview {\n      id\n    }\n  }\n}", 
            "title": "Connect two entries in a one-to-one relation"
        }, 
        {
            "location": "/API_simple/#connect-two-entries-in-a-one-to-many-relation", 
            "text": "One-to-many relations relate two models to each other.\nAn entry of the one side of a one-to-many relation can be connected to multiple entries. An entry of the many side of a one-to-many relation can at most be connected to one entry.  To creates a new edge between two entries you have to use the  addTo  mutation. The according models have to be in the same relation.\nThe query response can contain both entries of the new edge. The names of query arguments and entry names depend on the field names of the relation.  mutation {\n  addToTrackList(tracksTrackId:  cixnen2sddseq143bexdd52n , recordRecordId:  cixnen222dfsdwebexdd52n ) {\n    recordRecord {\n      id\n    }\n    tracksTrack {\n      id\n    }\n  }\n}  To remove one edge between two entries use the  removeFrom  mutation.\nThe query response can contain both entries of the former edge. The names of query arguments and entry names depend on the field names of the relation.  mutation {\n  removeFromTrackList(tracksTrackId:  cixnen2sddseq143bexdd52n , recordRecordId:  cixnen222dfsdwebexdd52n ) {\n    recordRecord {\n      id\n    }\n    tracksTrack {\n      id\n    }\n  }\n}   API docs are provided by GRAPHCOOL", 
            "title": "Connect two entries in a one-to-many relation"
        }, 
        {
            "location": "/API_relay/", 
            "text": "Relay API\n#\n\n\n\n\nRelay API docs will be available soon", 
            "title": "Relay"
        }, 
        {
            "location": "/API_relay/#relay-api", 
            "text": "Relay API docs will be available soon", 
            "title": "Relay API"
        }
    ]
}